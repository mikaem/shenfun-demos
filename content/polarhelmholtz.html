
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Demo - Helmholtz equation in polar coordinates &#8212; Shenfun executable demos</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "github-org/github-repo");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "ðŸ’¬ comment");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}, "extensions": ["cancel.js", "AMSmath.js"]}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Demo - Helmholtz equation on the unit sphere" href="sphericalhelmholtz.html" />
    <link rel="prev" title="Demo - 3D Poissonâ€™s equation" href="poisson3d.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      <img src="../_static/seashell3.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Shenfun executable demos</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Shenfun executable demos
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Shenfun executable demos
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="poisson.html">
   Demo - 1D Poissonâ€™s equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kleingordon.html">
   Demo - Cubic nonlinear Klein-Gordon equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="poisson3d.html">
   Demo - 3D Poissonâ€™s equation
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Demo - Helmholtz equation in polar coordinates
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="sphericalhelmholtz.html">
   Demo - Helmholtz equation on the unit sphere
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kuramatosivashinsky.html">
   Demo - Kuramato-Sivashinsky equation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stokes.html">
   Demo - Stokes equations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="drivencavity.html">
   Demo - Lid driven cavity
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rayleighbenard.html">
   Demo - Rayleigh Benard
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="functions.html">
   Demo - Working with Functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="surfaceintegration.html">
   Demo - Integration of functions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="moebius.html">
   Demo - Eigenvalues on the MÃ¶bius strip
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="fasttransforms.html">
   Demo - Some fast transforms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mixingbases.html">
   Demo - Mixed bases for the Helmholtz problem
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tau.html">
   Demo - The Tau method
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/content/polarhelmholtz.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/mikaem/shenfun-demos"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/mikaem/shenfun-demos/master?urlpath=tree/content/polarhelmholtz.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#helmholtz-equation">
   Helmholtz equation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#implementation">
   Implementation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#postprocessing">
   Postprocessing
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <!-- dom:TITLE: Demo - Helmholtz equation in polar coordinates -->
<div class="section" id="demo-helmholtz-equation-in-polar-coordinates">
<h1>Demo - Helmholtz equation in polar coordinates<a class="headerlink" href="#demo-helmholtz-equation-in-polar-coordinates" title="Permalink to this headline">Â¶</a></h1>
<!-- dom:AUTHOR: Mikael Mortensen Email:mikaem@math.uio.no at Department of Mathematics, University of Oslo. -->
<!-- Author: -->  
<p><strong>Mikael Mortensen</strong> (email: <code class="docutils literal notranslate"><span class="pre">mikaem&#64;math.uio.no</span></code>), Department of Mathematics, University of Oslo.</p>
<p>Date: <strong>April 8, 2020</strong></p>
<p><strong>Summary.</strong> This is a demonstration of how the Python module <a class="reference external" href="https://github.com/spectralDNS/shenfun">shenfun</a> can be used to solve the
Helmholtz equation on a circular disc, using polar coordinates. This demo is implemented in
a single Python file <a class="reference external" href="https://github.com/spectralDNS/shenfun/blob/master/demo/unitdisc_helmholtz.py">unitdisc_helmholtz.py</a>,
and the numerical method is described in more detail by J. Shen <a class="reference external" href="#shen3">[shen3]</a>.</p>
<!-- dom:FIGURE: [https://rawgit.com/spectralDNS/spectralutilities/master/figures/Helmholtzdisc.png, width=700 frac=1] Helmholtz on the unit disc. <a id="fig:helmholtz"></a> -->
<!-- begin figure -->
<p><a id="fig:helmholtz"></a></p>
<p>Helmholtz on the unit disc.</p>
<img src="https://rawgit.com/spectralDNS/spectralutilities/master/figures/Helmholtzdisc.png" width=700>
<!-- end figure -->
<div class="section" id="helmholtz-equation">
<h2>Helmholtz equation<a class="headerlink" href="#helmholtz-equation" title="Permalink to this headline">Â¶</a></h2>
<p><a id="demo:polar_helmholtz"></a></p>
<p>The Helmholtz equation is given as</p>
<!-- Equation labels as ordinary links -->
<p><a id="eq:helmholtz"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
-\nabla^2 u(\boldsymbol{x}) + \alpha u(\boldsymbol{x}) = f(\boldsymbol{x}) \quad \text{for }\, \boldsymbol{x}=(x, y) \in \Omega, \label{eq:helmholtz} \tag{1}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto1"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u =0 \text{ on } \partial \Omega,
\label{_auto1} \tag{2}
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(u(\boldsymbol{x})\)</span> is the solution, <span class="math notranslate nohighlight">\(f(\boldsymbol{x})\)</span> is a function and <span class="math notranslate nohighlight">\(\alpha\)</span> a constant.
The domain is a circular disc <span class="math notranslate nohighlight">\(\Omega = \{(x, y): x^2+y^2 &lt; a^2\}\)</span> with radius <span class="math notranslate nohighlight">\(a\)</span>.
We use polar coordinates <span class="math notranslate nohighlight">\((\theta, r)\)</span>, defined as</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto2"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
 x = r \cos \theta, 
\label{_auto2} \tag{3}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto3"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
 y = r \sin \theta,
\label{_auto3} \tag{4}
\end{equation}
\]</div>
<p>which leads to a Cartesian product mesh <span class="math notranslate nohighlight">\((\theta, r) \in [0, 2\pi) \times [0, a]\)</span>
suitable for numerical implementations. Note that the
two directions are ordered with <span class="math notranslate nohighlight">\(\theta\)</span> first and then <span class="math notranslate nohighlight">\(r\)</span>, which is less common
than <span class="math notranslate nohighlight">\((r, \theta)\)</span>. This has to do with the fact that we will need to
solve linear equation systems along the radial direction, but not
the <span class="math notranslate nohighlight">\(\theta\)</span>-direction, since Fourier matrices are diagonal. When
the radial direction is placed last, the data in the radial direction
will be contigeous in a row-major C memory, leading to faster memory
access where it is needed the most. Note that it takes very few
changes in <code class="docutils literal notranslate"><span class="pre">shenfun</span></code> to switch the directions to <span class="math notranslate nohighlight">\((r, \theta)\)</span> if this
is still desired.</p>
<p>We will use Chebyshev
or Legendre basis functions <span class="math notranslate nohighlight">\(\psi_j(r)\)</span> for the radial direction and
a periodic Fourier expansion in <span class="math notranslate nohighlight">\(\exp(\imath k \theta)\)</span> for the
azimuthal direction. The polar basis functions are as such</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto4"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
v_{kj}(\theta, r) = \exp(\imath k \theta) \psi_j(r),
\label{_auto4} \tag{5}
\end{equation}
\]</div>
<p>and we look for solutions</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto5"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u(\mathbf{x}) = \tilde{u}(\theta, r) = \sum_{k} \sum_{j} \hat{u}_{kj} v_{kj}(\theta, r).
\label{_auto5} \tag{6}
\end{equation}
\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\tilde{u}\)</span> is the function <span class="math notranslate nohighlight">\(u\)</span> mapped to computational space.
From now on we will simply use <span class="math notranslate nohighlight">\(u(\theta, r)\)</span> without the tilde, and assume that
the proper version of the function is understood from its arguments.</p>
<p>A discrete Fourier approximation space with <span class="math notranslate nohighlight">\(N\)</span> basis functions is then</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto6"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
V_F^N = \text{span} \{\exp(\imath k \theta)\}, \text{ for } k \in K,
\label{_auto6} \tag{7}
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(K = \{-N/2, -N/2+1, \ldots, N/2-1\}\)</span>. Since the solution <span class="math notranslate nohighlight">\(u(\theta, r)\)</span>
is real, there is Hermitian symmetry and <span class="math notranslate nohighlight">\(\hat{u}_{k,j} = \hat{u}_{k,-j}^*\)</span>
(with <span class="math notranslate nohighlight">\(*\)</span> denoting a complex conjugate).
For this reason we use only <span class="math notranslate nohighlight">\(k \in K=\{0, 1, \ldots, N/2\}\)</span> in solving for
<span class="math notranslate nohighlight">\(\hat{u}_{kj}\)</span>, and then use Hermitian symmetry to get the remaining
unknowns.</p>
<p>The radial basis is more tricky, because there is a nontrivial â€˜boundaryâ€™
condition (pole condition) that needs to be applied at the center of the disc <span class="math notranslate nohighlight">\((r=0)\)</span></p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto7"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\frac{\partial u(\theta, 0)}{\partial \theta} = 0.
\label{_auto7} \tag{8}
\end{equation}
\]</div>
<p>To apply this condition we split the solution into Fourier
coefficients with wavenumber 0 and <span class="math notranslate nohighlight">\(K\backslash \{0\}\)</span>,
remembering that the Fourier basis function with <span class="math notranslate nohighlight">\(k=0\)</span> is
simply 1</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto8"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u(\theta, r) = \sum_{j} \left( \hat{u}_{0j} \psi_{j}(r) + \sum_{k=1}^{N/2} \hat{u}_{kj} \exp(\imath k \theta) \psi_j(r) \right).
\label{_auto8} \tag{9}
\end{equation}
\]</div>
<p>We then apply a different radial basis for the two <span class="math notranslate nohighlight">\(\psi\)</span>â€™s in
the above equation (renaming the first <span class="math notranslate nohighlight">\(\overline{\psi}\)</span>)</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto9"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u(\theta, r) = \sum_{j} \left( \hat{u}_{0j} \overline{\psi}_{j}(r) + \sum_{k=1}^{N/2} \hat{u}_{kj} \exp(\imath k \theta) \psi_j(r) \right).
\label{_auto9} \tag{10}
\end{equation}
\]</div>
<p>Note that the first term <span class="math notranslate nohighlight">\(\sum_{j} \hat{u}_{0j} \overline{\psi}_{j}(r)\)</span> is independent
of <span class="math notranslate nohighlight">\(\theta\)</span>. Now, to enforce conditions</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto10"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u(\theta, a) = 0, 
\label{_auto10} \tag{11}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto11"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\frac{\partial u(\theta, 0)}{\partial \theta} = 0,
\label{_auto11} \tag{12}
\end{equation}
\]</div>
<p>it is sufficient for the two bases (<span class="math notranslate nohighlight">\(\overline{\psi}\)</span> and <span class="math notranslate nohighlight">\(\psi\)</span>) to
satisfy</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto12"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\overline{\psi}_j(a) = 0, 
\label{_auto12} \tag{13}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto13"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\psi_j(a) = 0,
\label{_auto13} \tag{14}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto14"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\psi_j(0) = 0.
\label{_auto14} \tag{15}
\end{equation}
\]</div>
<p>Bases that satisfy these conditions can be found both with Legendre and
Chebyshev polynomials.
If <span class="math notranslate nohighlight">\(\phi_j(x)\)</span> is used for either the Legendre polynomial <span class="math notranslate nohighlight">\(L_j(x)\)</span> or the
Chebyshev polynomial of the first kind <span class="math notranslate nohighlight">\(T_j(x)\)</span>, we can have</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto15"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\overline{\psi}_j(r) = \phi_j(2r/a-1) - \phi_{j+1}(2r/a-1), \text{ for } j \in 0, 1, \ldots N-1, 
\label{_auto15} \tag{16}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="eq:psi"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\psi_j(r) = \phi_j(2r/a-1) - \phi_{j+2}(2r/a-1), \text{ for } j \in 0, 1, \ldots N-2.
\label{eq:psi} \tag{17}
\end{equation}
\]</div>
<p>Define the following approximation spaces for the radial direction</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto16"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
V_D^N = \text{span} \{\psi_j\}_{j=0}^{N-3} 
\label{_auto16} \tag{18}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto17"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
V_U^N = \text{span} \{\overline{\psi}_j\}_{j=0}^{N-2} 
\label{_auto17} \tag{19}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto18"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
\label{_auto18} \tag{20}
\end{equation}
\]</div>
<p>and split the function space for the azimuthal direction into</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto19"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
V_F^0 =  \text{span}\{1\}, 
\label{_auto19} \tag{21}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto20"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
V_F^{1} = \text{span} \{\exp(\imath k \theta)\}, \text{ for } k \in K \backslash \{0\}.
\label{_auto20} \tag{22}
\end{equation}
\]</div>
<p>We then look for solutions</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto21"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u(\theta, r) = u^0(r) + u^1(\theta, r),
\label{_auto21} \tag{23}
\end{equation}
\]</div>
<p>where</p>
<!-- Equation labels as ordinary links -->
<p><a id="_auto22"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
u^0(r) = \sum_{j=0}^{N-2} \hat{u}^0_j \overline{\psi}_j(r), 
\label{_auto22} \tag{24}
\end{equation}
\]</div>
<!-- Equation labels as ordinary links -->
<p><a id="_auto23"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}  
u^1(\theta, r) = \sum_{j=0}^{N-3}\sum_{k=1}^{N/2} \hat{u}^1_{kj} \exp(\imath k \theta) \psi_j(r) .
\label{_auto23} \tag{25}
\end{equation}
\]</div>
<p>As such the Helmholtz problem is split in two smaller problems.
The two problems read with the spectral Galerkin method:</p>
<p>Find <span class="math notranslate nohighlight">\(u^0 \in V_F^0 \otimes V_U^N\)</span> such that</p>
<!-- Equation labels as ordinary links -->
<p><a id="eq:u0"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
   \int_{\Omega} (-\nabla^2 u^0 + \alpha u^0) v^0 w d\sigma = \int_{\Omega} f v^0 w d\sigma, \quad \forall \, v^0 \in V_F^0 \otimes V_U^N.
\label{eq:u0} \tag{26}
   \end{equation}
\]</div>
<p>Find <span class="math notranslate nohighlight">\(u^1 \in V_F^1 \otimes V_D^N\)</span> such that</p>
<!-- Equation labels as ordinary links -->
<p><a id="eq:u1"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
   \int_{\Omega} (-\nabla^2 u^1 + \alpha u^1) v^1 w d\sigma = \int_{\Omega} f v^1 w d\sigma, \quad \forall \, v^1 \in V_F^1 \otimes V_D^N.
\label{eq:u1} \tag{27}
   \end{equation}
\]</div>
<p>Note that integration over the domain is done using
polar coordinates with an integral measure of <span class="math notranslate nohighlight">\(d\sigma=rdrd\theta\)</span>.
However, the integral in the radial direction needs to be mapped
to <span class="math notranslate nohighlight">\(t=2r/a-1\)</span>, where <span class="math notranslate nohighlight">\(t \in [-1, 1]\)</span>, which suits the basis functions used,
see (<a class="reference external" href="#eq:psi">17</a>). This leads to a measure of <span class="math notranslate nohighlight">\(0.5(t+1)adtd\theta\)</span>.
Furthermore, the weight <span class="math notranslate nohighlight">\(w(t)\)</span> will be unity for the Legendre basis and
<span class="math notranslate nohighlight">\((1-t^2)^{-0.5}\)</span> for the Chebyshev bases.</p>
</div>
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">Â¶</a></h2>
<p><a id="demo:polarimplementation"></a></p>
<p>A complete implementation is found in the file <a class="reference external" href="https://github.com/spectralDNS/shenfun/blob/master/demo/unitdisc_helmholtz.py">unitdisc_helmholtz.py</a>.
Here we give a brief explanation for the implementation. Start by
importing all functionality from <a class="reference external" href="https://github.com/spectralDNS/shenfun">shenfun</a>
and <a class="reference external" href="https://sympy.org">sympy</a>, where Sympy is required for handeling the
polar coordinates. Also, we choose to work with covariant
basis vectors.</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">shenfun</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sympy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="n">config</span><span class="p">[</span><span class="s1">&#39;basisvectors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;covariant&#39;</span>

<span class="c1"># Define polar coordinates using angle along first axis and radius second</span>
<span class="n">theta</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">r</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="c1"># Map to Cartesian (x, y)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that Sympy symbols are both positive and real, <span class="math notranslate nohighlight">\(\theta\)</span> is
chosen to be along the first axis and <span class="math notranslate nohighlight">\(r\)</span> second. This has to agree with
the next step, which is the creation of tensorproductspaces
<span class="math notranslate nohighlight">\(V_F^0 \otimes V_U^N\)</span> and <span class="math notranslate nohighlight">\(V_F^1 \otimes V_D^N\)</span>. We use
<code class="docutils literal notranslate"><span class="pre">domain=(0,</span> <span class="pre">1)</span></code> for the radial direction to get a unit disc, whereas
the default domain for the Fourier bases is already the
required <span class="math notranslate nohighlight">\((0, 2\pi)\)</span>.</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="n">F0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">L0</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="n">bc</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TensorProductSpace</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">coordinates</span><span class="o">=</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">rv</span><span class="p">))</span>
<span class="n">T0</span> <span class="o">=</span> <span class="n">TensorProductSpace</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_SELF</span><span class="p">,</span> <span class="p">(</span><span class="n">F0</span><span class="p">,</span> <span class="n">L0</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">coordinates</span><span class="o">=</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">rv</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Note that since <code class="docutils literal notranslate"><span class="pre">F0</span></code> only has one component we could actually use
<code class="docutils literal notranslate"><span class="pre">L0</span></code> without creating <code class="docutils literal notranslate"><span class="pre">T0</span></code>. But the code turns out to be simpler
if we use <code class="docutils literal notranslate"><span class="pre">T0</span></code>, much because the additional <span class="math notranslate nohighlight">\(\theta\)</span>-direction is
required for the polar coordinates to apply. Using one single basis
function for the <span class="math notranslate nohighlight">\(\theta\)</span> direction is as such a generic way to handle
polar 1D problems (i.e., problems that are only functions of the
radial direction, but still using polar coordinates).
Also note that <code class="docutils literal notranslate"><span class="pre">F</span></code> is created using the entire range of wavenumbers
even though it should not include wavenumber 0.
As such we need to make sure that the coefficient created for
<span class="math notranslate nohighlight">\(k=0\)</span> (i.e., <span class="math notranslate nohighlight">\(\hat{u}^1_{0,j}\)</span>) will be exactly zero.
Finally, note that
<code class="docutils literal notranslate"><span class="pre">T0</span></code> is not distributed with MPI, which is accomplished using
<code class="docutils literal notranslate"><span class="pre">MPI.COMM_SELF</span></code> instead of <code class="docutils literal notranslate"><span class="pre">comm</span></code> (which equals <code class="docutils literal notranslate"><span class="pre">MPI.COMM_WORLD</span></code>).
The purely radial problem (<a class="reference external" href="#eq:u0">26</a>) is only solved on the one
processor with rank = 0.</p>
<p>Polar coordinates are ensured by feeding <code class="docutils literal notranslate"><span class="pre">coordinates=(psi,</span> <span class="pre">rv)</span></code>
to <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.html#shenfun.tensorproductspace.TensorProductSpace">TensorProductSpace</a>. Operators like <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.operators.div">div()</a>
<a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.operators.grad">grad()</a> and  <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.operators.curl">curl()</a> will now work on
items of <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.arguments.Function">Function</a>, <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.arguments.TestFunction">TestFunction</a> and
<a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.arguments.TrialFunction">TrialFunction</a> using a polar coordinate system.</p>
<p>To define the equations (<a class="reference external" href="#eq:u0">26</a>) and (<a class="reference external" href="#eq:u1">27</a>) we first declare
these test- and trialfunctions, and then use code that
is remarkably similar to the mathematics.</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">v0</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">mats</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">+</span><span class="n">alpha</span><span class="o">*</span><span class="n">u</span><span class="p">)</span>
<span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">mats0</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="o">-</span><span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u0</span><span class="p">))</span><span class="o">+</span><span class="n">alpha</span><span class="o">*</span><span class="n">u0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">mats</span></code> and <code class="docutils literal notranslate"><span class="pre">mats0</span></code> will contain several tensor product
matrices in the form of
<a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.html#shenfun.matrixbase.TPMatrix">TPMatrix</a>. Since there is only one non-periodic direction
the matrices can be easily solved using <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.html#shenfun.la.SolverGeneric1ND">SolverGeneric1ND</a>.
But first we need to define the function <span class="math notranslate nohighlight">\(f(\theta, r)\)</span>.
To this end we use sympy and the method of
manufactured solution to define a possible solution <code class="docutils literal notranslate"><span class="pre">ue</span></code>,
and then compute <code class="docutils literal notranslate"><span class="pre">f</span></code> exactly using exact differentiation</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Manufactured solution</span>
<span class="n">ue</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="n">theta</span><span class="p">)</span><span class="o">-</span><span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#f = -ue.diff(r, 2) - (1/r)*ue.diff(r, 1) - (1/r**2)*ue.diff(theta, 2) + alpha*ue</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">div</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">+</span><span class="n">alpha</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">tosympy</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">ue</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">)</span>

<span class="c1"># Compute the right hand side on the quadrature mesh</span>
<span class="n">fj</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

<span class="c1"># Take scalar product</span>
<span class="n">f_hat</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">f_hat</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">fj</span><span class="p">,</span> <span class="n">output_array</span><span class="o">=</span><span class="n">f_hat</span><span class="p">)</span>
<span class="k">if</span> <span class="n">T</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># The processor that owns k=0</span>
    <span class="n">f_hat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># For k=0 we solve only a 1D equation. Do the scalar product for Fourier</span>
<span class="c1"># coefficient 0 by hand (or sympy).</span>
<span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">f0_hat</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
    <span class="n">gt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sp</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">sp</span><span class="o">.</span><span class="n">pi</span><span class="p">)(</span><span class="n">L0</span><span class="o">.</span><span class="n">mesh</span><span class="p">())</span>
    <span class="n">f0_hat</span> <span class="o">=</span> <span class="n">T0</span><span class="o">.</span><span class="n">scalar_product</span><span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="n">f0_hat</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Note that for <span class="math notranslate nohighlight">\(u^0\)</span> we perform the interal in the <span class="math notranslate nohighlight">\(\theta\)</span> direction
exactly using sympy. This is necessary since one Fourier coefficient
is not sufficient to do this integral numerically. For the <span class="math notranslate nohighlight">\(u^1\)</span>
case we do the integral numerically as part of the <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.inner.inner">inner()</a> product.
With the correct right hand side assembled we can solve the
linear system of equations</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">u_hat</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="n">Sol1</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">SolverGeneric1ND</span><span class="p">(</span><span class="n">mats</span><span class="p">)</span>
<span class="n">u_hat</span> <span class="o">=</span> <span class="n">Sol1</span><span class="p">(</span><span class="n">f_hat</span><span class="p">,</span> <span class="n">u_hat</span><span class="p">)</span>

<span class="c1"># case k = 0</span>
<span class="n">u0_hat</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">T0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">Sol0</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">SolverGeneric1ND</span><span class="p">(</span><span class="n">mats0</span><span class="p">)</span>
    <span class="n">u0_hat</span> <span class="o">=</span> <span class="n">Sol0</span><span class="p">(</span><span class="n">f0_hat</span><span class="p">,</span> <span class="n">u0_hat</span><span class="p">)</span>
<span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">u0_hat</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Having found the solution in spectral space all that is
left is to transform it back to real space.</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transform back to real space. Broadcast 1D solution</span>
<span class="n">sl</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">uj</span> <span class="o">=</span> <span class="n">u_hat</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span> <span class="o">+</span> <span class="n">u0_hat</span><span class="o">.</span><span class="n">backward</span><span class="p">()[:,</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="postprocessing">
<h2>Postprocessing<a class="headerlink" href="#postprocessing" title="Permalink to this headline">Â¶</a></h2>
<p>The solution can now be compared with the exact solution
through</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uq</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">ue</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error =&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">uj</span><span class="o">-</span><span class="n">uq</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We can also get the gradient of the solution. For this we need
a space without boundary conditions, and a vector space</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">TT</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">get_orthogonal</span><span class="p">()</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">VectorSpace</span><span class="p">(</span><span class="n">TT</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that we do not have the solution in one single space
in spectral space, since it is a combination of <code class="docutils literal notranslate"><span class="pre">u_hat</span></code> and
<code class="docutils literal notranslate"><span class="pre">u0_hat</span></code>. For this reason we first transform the solution from
real space <code class="docutils literal notranslate"><span class="pre">uj</span></code> to the new orthogonal space <code class="docutils literal notranslate"><span class="pre">TT</span></code></p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ua</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">uj</span><span class="p">)</span>
<span class="n">uh</span> <span class="o">=</span> <span class="n">ua</span><span class="o">.</span><span class="n">forward</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>With the solution as a <a class="reference external" href="https://shenfun.readthedocs.io/en/latest/shenfun.forms.html#shenfun.forms.arguments.Function">Function</a> we can simply project
the gradient to <code class="docutils literal notranslate"><span class="pre">V</span></code></p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dv</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">uh</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">dv</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Note that the gradient <code class="docutils literal notranslate"><span class="pre">du</span></code> now contains the contravariant components
of the covariant basis vector <code class="docutils literal notranslate"><span class="pre">b</span></code>. The basis vector <code class="docutils literal notranslate"><span class="pre">b</span></code> is not normalized
(itâ€™s length is not unity), because we have set
<code class="docutils literal notranslate"><span class="pre">config['basisvectors']='covariant'</span></code>. The basisvectors can
be seen as</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Math</span>
<span class="n">Math</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">coors</span><span class="o">.</span><span class="n">latex_basis_vectors</span><span class="p">(</span><span class="n">symbol_names</span><span class="o">=</span><span class="p">{</span><span class="n">theta</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">theta&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="s1">&#39;r&#39;</span><span class="p">}))</span>
</pre></div>
</div>
</div>
</div>
<p>and we see that they are given in terms of the Cartesian unit vectors.
The gradient we have computed is (and yes, it should be <span class="math notranslate nohighlight">\(r^2\)</span> because we
do not have unit vectors)</p>
<!-- Equation labels as ordinary links -->
<p><a id="eq:gradu"></a></p>
<div class="math notranslate nohighlight">
\[
\begin{equation}
\nabla u = \underbrace{\frac{1}{r^2}\frac{\partial u}{\partial \theta}}_{du[0]}\mathbf{b}_{\theta} + \underbrace{\frac{\partial u}{\partial r}}_{du[1]} \mathbf{b}_{r}
\label{eq:gradu} \tag{28}
\end{equation}
\]</div>
<p>Now it makes sense to plot the solution and its gradient in Cartesian
instead of computational coordinates. To this end we need to
project the gradient to a Cartesian basis</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\frac{\partial u}{\partial x} &amp;= \nabla u \cdot \mathbf{i},\\ 
\frac{\partial u}{\partial y} &amp;= \nabla u \cdot \mathbf{j}.
\end{align*}
\end{split}\]</div>
<p>We compute the Cartesian gradient by assembling (<a class="reference external" href="#eq:gradu">28</a>)
on the computational grid</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ui</span><span class="p">,</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">TT</span><span class="o">.</span><span class="n">local_mesh</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">coors</span><span class="o">.</span><span class="n">get_covariant_basis</span><span class="p">()</span>
<span class="n">bij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">b</span><span class="p">)(</span><span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">))</span>
<span class="n">gradu</span> <span class="o">=</span> <span class="n">du</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">bij</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">du</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">bij</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Because of the way the vectors are stored, <code class="docutils literal notranslate"><span class="pre">gradu[0]</span></code> will now
contain <span class="math notranslate nohighlight">\(\nabla u \cdot \mathbf{i}\)</span> and
<code class="docutils literal notranslate"><span class="pre">gradu[1]</span></code> will contain <span class="math notranslate nohighlight">\(\nabla u \cdot \mathbf{j}\)</span>.</p>
<p>To validate the gradient we compute the <span class="math notranslate nohighlight">\(L^2\)</span> error norm</p>
<div class="math notranslate nohighlight">
\[
\sqrt{\int_{\Omega} |\nabla u - \nabla u_e|^2 d\sigma}
  = \sqrt{\int_{\theta=0}^{2\pi}\int_{r=0}^{1} \left(\left(\frac{1}{r^2}\frac{\partial u-u_e}{\partial \theta}\right)^2\mathbf{b}_{\theta}\cdot \mathbf{b}_{\theta} + \left(\frac{\partial u-u_e}{\partial r}\right)^2\mathbf{b}_{r}\cdot \mathbf{b}_{r} \right)rd\theta dr}
\]</div>
<p>implemented as</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gradue</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">tosympy</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">ue</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">))</span>
<span class="n">gij</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">coors</span><span class="o">.</span><span class="n">get_covariant_metric_tensor</span><span class="p">()</span>
<span class="n">ui</span><span class="p">,</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">TT</span><span class="o">.</span><span class="n">local_mesh</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">uniform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Evaluate metric on computational mesh</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">gij</span><span class="p">)(</span><span class="n">ui</span><span class="p">,</span> <span class="n">vi</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="c1"># Compute L2 error</span>
<span class="n">errorg</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">du</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">gradue</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span> <span class="p">(</span><span class="n">du</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">gradue</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error gradient&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">errorg</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>We now refine the solution to make it look better,
and plot on the unit disc.</p>
<div class="cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="n">u_hat2</span> <span class="o">=</span> <span class="n">u_hat</span><span class="o">.</span><span class="n">refine</span><span class="p">([</span><span class="n">N</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="mi">3</span><span class="p">])</span>
<span class="n">u0_hat2</span> <span class="o">=</span> <span class="n">u0_hat</span><span class="o">.</span><span class="n">refine</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="mi">3</span><span class="p">])</span>
<span class="n">sl</span> <span class="o">=</span> <span class="n">u_hat2</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">local_slice</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ur</span> <span class="o">=</span> <span class="n">u_hat2</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span> <span class="o">+</span> <span class="n">u0_hat2</span><span class="o">.</span><span class="n">backward</span><span class="p">()[:,</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

<span class="c1"># Wrap periodic plot around since it looks nicer</span>
<span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">u_hat2</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">local_cartesian_mesh</span><span class="p">()</span>
<span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xx</span><span class="p">,</span> <span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">yp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">yy</span><span class="p">,</span> <span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ur</span><span class="p">,</span> <span class="n">ur</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># For vector no need to wrap around and no need to refine:</span>
<span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">TT</span><span class="o">.</span><span class="n">local_cartesian_mesh</span><span class="p">()</span>

<span class="c1"># plot</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">up</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">gradu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gradu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Helmholtz - unitdisc&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<!-- ======= Bibliography ======= -->
<ol class="simple">
<li><p><a id="shen3"></a> <strong>J. Shen</strong>.
Efficient Spectral-Galerkin Methods III: Polar and Cylindrical Geometries,
<em>SIAM Journal on Scientific Computing</em>,
18(6),
pp. 1583-1604,
<a class="reference external" href="http://dx.doi.org/10.1137/S1064827595295301">doi: 10.1137/S1064827595295301</a>,
1997.</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "mikaem/shenfun-demos",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="poisson3d.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Demo - 3D Poissonâ€™s equation</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="sphericalhelmholtz.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Demo - Helmholtz equation on the unit sphere</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Mikael Mortensen<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>